
Moxie created Signal. Secure messenger. 
Wanted to pitch first, when he was a kid magic existed.  didn't read HP until he was an adult. He didn't understand school or school work. he didn't get why they didn't want to do it.  Middle school had a req music classs. 
The class was handbells, If you had top minds destroy a child's desire to learn music you'd do handbells.
If you learn the spells you can do actual magic, and these kids don't want to learn it. 
If access, he wouldn't want to leave.  We too have rooms filled with boooks which have knowledge, and we can also do cool *stuff* if we read them.  The knowledge is all in these books. All we gotta do is learn that knowledge. This doesn't feel the same. 
- Big diff is in the HP world, is all they need is knowledge and a want.  They don't need people, permits, or the economy, or capital 
- In our world we need all this *stuff* to do anything. 
Software is different....

- Softwhere is where magic exists.  You don't need people, permits, licenses, capital, you just need a computer. not even a good one. 
- It is rare, it is actual magic.  
- This magic has been diminishing over time.....

Software is really interesting/unusual.  They are computer science majors, but call emselves engineers.  But they call themselves engineers.....
Seems like it's engineering, it exists in a fully known universe we made.  We don't have to discover anything. This is different then worlds we did not invent and didn't understand.  So science is basically the process of discovery.  
Software is about getting from A -> B.
It's unlike other disciplines.  

Software seems straightforward.  You ciopmile and assemble something to manifest your vision. 

The relationship between vision and engineering is bidirectional.  Consider a GIF.  
What's interesting is they aren't actually animating, that's what it looks like is happening, but that's not feasible for the ime it was made.  Instead it's images using something called color cycling.  Meaning they were indexed color systems.  So you rep every byte you end up as being dev'd as a mem optimization technique, so every color val gets one byte.  An image maps the color RGB values, and you look things up, and the color gets displayed on the screen.  
But for any individual study or mapping in the color pallet, you have a value many things can reference at the same time, so you can update 10000000 things with one write.  So you start changing things in groups.  So you can carefully construct an image, and if you cycle the values of the paelet at a rate, it looks like an animation that should be impossible. 
These tricks get combined, to make things like a bowling ball demo.  So rotation looks like it's happening because of color cycling, but it's not.  This is not an obvious result.  The indexed color systems weren't made for this purpose. 

So just by cycling electricity quickly we get from there to cat meme's.  So the history of software and computing is a bunch of repeated discovery, but engineering is the basis of discovery.  So if we use something that's simple. 

for (;;){}
vision for these images did not emerge first.  The vision was developed and iinformed in a bidirectional relationship with the system.
Tools and technology combine for a surprising result big or small that are all intertwined.  
That is not some new product/demo, it's a smaller advancement that always starts with the understanding part.  New technology is the combo of tech.  Creates a computer that's complex enough.  For things that generate new and surprising results. 
Understanding has diminished over time for things.

Software relies on abstraction layers.  This is arduous, so it's good to extract that data out and make it feel less complex.  Same is true for sockets, C, game engines, etc. Any abstraction. 
One is, abstraction is shorthand for whatever you're doing and the other is to treat it as a black box.  

So interface shorthand is an interface for what it is it's doing.  What it's doing on your behalf, and how it works.  You use an interface as a black box and have no idea what it's doing.  The problem is, these interfaces are never perfect or perfectly clean. 
So when you use them as black boxes without knowing what they're doing, issues compound. 

What more is,  what is going on is related to vision and engineering.
So if you see every abstraction as a black box, it makes it difficult to have vision.  Sometimes we make these layers without haveing to understand what happens beneath them.  We would think this owuld make an explosion of creativity.  This seems true for domains in which it's outside of computing.  
We may say a film maker can make a film without understanding how a camera works.  So a fiml maker not knowing camera internals doesn't reflect the film.  
So you could say. Having folks who make games can use abstractions they can focus on creative with abstractions.  But the problem with the issue.... a camera is not an abstraction layer for a film. There's other stuff going on a fimlm maker does have to understand.  You can't just have a good story.  All the mechanics need to be understood.  So when we take this into the realm of computing, we do actually see an increase in stuff.  We see more things, but we see more *stuff* and mediocre things. 
So, games and game engines, we see more, but there are a lot less good games.  We have just optimized pushing garbage.
So we're seeing more stuff, but not more good stuff.

This is connected to the relationship between vision/engineering and vision/discovery.  It's rooted in deep understanding to help achieve that creativity.  We can only create when we truly understand what we can make with that cool stuff.
This applies to the meta industry as a whole.  It applies to groups.
What it makes to be a good engineer is what it takes to make a good engineering organization.  OVer the past few years, engineering orgs, these orgs have ballooned,  but these orgs don't have a rep for high velocity output.  So it's more difficult to iterate on something used by billions versus thousands.  Having seen inside of these, there's more going on here. And it's related to vision & engineering relationship.

Anyone managing an engineering organization today, will ave something related to agile. 
So information flows up to the leaders, and decisions flow back down in the form of budgets, priorities, headcounts.  So instead orgs are composed of autonomous teams.  So agile is supposed to create alignment across teams.  It sounds like vision leads to engineering in this case.
Engineering of the vision doesn't help with the intertwining.  It doesn't let both play with each other.  It's made worse by autonomous teams.
Autonomous teams look alot like abstraction layers, or a mciroservice architecture inside of an organization.

Imagine that an org is skype at the dawn of mobile.  You have all of these silo'd engineers.  You as the skype leadership can see mobile is important, so you communicate it as important and try to align everyone as an autonomous team.  It's still a big lift to get folks to swap to it.  You have a user UX which is surrounding conflict of on/offline.  There's this semi distributed mesh that need ssomething that isn't possible on a mobile device. 
So everything needs to change.

But the change every team needs to make is interdependent on every other team.  So the product normally would be an intertwined relationship that's informed. 
If you have everyone in the org composed of these layers, it's difficult to make that change happen. The less the org is composed of these abstractions the more effective they'll be.

Even if you see it as a black swan event.  Orgs that aren't capable of making this change are leaving a lot on the table.
We've spent last 20 years of putting folks in orgs and teaching them to only use abstractions..... and working in these abstractions...

The basis for understanding and discovery in software, where understanding yields great outcomes, is the fundamental and inescapable foundation of good security research.  

security is the process of looking through abstractions and understanding them better than anyone else.  When you do that you can see how these things don't cleanly stack on each other, where they're leaky, where they behave strangely.  That is cool and valuable in the context of security.  But without knowing it, security folks are the best because no one else, no software engineers know this anymore. 

we spent 20 years inhibiting engineerss for software, while everyone else tries to undesrstand how abstracted software works.  Good security folks go ahead and tried to understand how that all works anyway. That's the difference between good vs. bad.  The understanding of what is being abstracted.  Not the abstraction.
IE) knowing how to allocate memory in C vs. assembly.  Or knowing how Python allocates memory and what is lost in the abstraction as Python is an abstraction of C which is an abstraction of assembly. 

  The only thing you need to use, is a computer,  and it doesn't have to be a good one.  You just need to look at the problems, think about how the things you understand work, and how everything interacts.  The secret is to begin. 

Origin of redphone. 
- [ ] People develop an identity around arcane knowledge, and the cultural norms you have to undermine, as doing that undermines own identities. 
- Thie histtory of privacy enhancing tech takes twists and turns.  Privacy and crypto folks knew it was important.  And then the web happened.  The web was bad for crypto, because you need to have ends.  So you need software endpoints that can maintain some state.  If all software is all a web app. then an app is just a view into the server.  So the logic itself doesn't exists in the browser.  So it's hard to have end to end encryption.  So mobile, the software you can run on phones.  Which runs something that can maintain a state is a great opportunity.  
- So you build something. And it becomes successful, and you have to involve more people, how does that go.
	- I think that one thing about software is, in many ways, it's more difficult over time.  This opportunity makes itmore difficult.  you need 2 mobile and a desktop app, which is not sustainable for one person.  So then it turns into teams.  So this is occurring while you're gaining signal success, so you build out because more users.  So you're scaling out. And theere is essentially two types of software development. 
	- I envy writers/film makers / musicians, people who can make something and be done.  there's no maintenance work, it's fine for 20 years.
		- Software is never finished.  So what it requires is a person and maybe a group of people. to always look at it.  It's not something you can do one time and be finished with it. 
		- So that's an expensive proposition, so it can exist at scale really easily.  It all has to be at a certain scale to help with the cost associated with building it.  So at low scale, existing for like a hundred people.  If they're willing to pay 10$ a year or a month, you have to be at scale.  So the businesses are what you don't need scale.
